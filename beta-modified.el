; Beta Code (modified) implementation in Emacs Lisp (Modified)
; To apply: type: M-x beta-1 <return>
; Or: type: M-x b-1 <return>
; Then type the (Modified) Beta Code for an Ancient Greek word or phrase, then press <return> again.
; This version implements all of the features except for macrons and breves (for scanning poetry), digamma, and lunate sigma. (But the correspondence scheme is modified; see the two matched lines right below.)

; ABCDEFGHIJKLMNOPQRS5TUWXZ
; αβθδεφγηιχκλμνοπψρσςτυωξζ


; global variables
(setq iotasub 0)
(setq breath 0)
(setq accent 0)
(setq diaeresis 0)

(defun beta-char (ch)
    "Decodes a single character (CH) which is not for a breath mark or iota subscript."
    (cond
        ((string= ch " ") " ")
	((string= ch ",") ",")
	((string= ch ".") ".")
	((string= ch ":") "·")
	((string= ch ";") ";")
	((string= ch "'") "’")
	((string= ch "\-") "\-")
	((string= ch "_") "—")
	((string= ch "#") "ʹ")
	((string= ch "a")
	    (cond
	        ((and (eq iotasub 0) (eq breath 0) (eq accent 0)) "α")
		((and (eq iotasub 0) (eq breath 0) (eq accent 1)) "ά")
		((and (eq iotasub 0) (eq breath 0) (eq accent 2)) "ὰ")
		((and (eq iotasub 0) (eq breath 0) (eq accent 3)) "ᾶ")
		((and (eq iotasub 0) (eq breath 1) (eq accent 0)) "ἀ")
		((and (eq iotasub 0) (eq breath 2) (eq accent 0)) "ἁ")
		((and (eq iotasub 0) (eq breath 1) (eq accent 1)) "ἄ")
		((and (eq iotasub 0) (eq breath 2) (eq accent 1)) "ἅ")
		((and (eq iotasub 0) (eq breath 1) (eq accent 2)) "ἂ")
		((and (eq iotasub 0) (eq breath 2) (eq accent 2)) "ἃ")
		((and (eq iotasub 0) (eq breath 1) (eq accent 3)) "ἆ")
		((and (eq iotasub 0) (eq breath 2) (eq accent 3)) "ἇ")
	        ((and (eq iotasub 1) (eq breath 0) (eq accent 0)) "ᾳ")
		((and (eq iotasub 1) (eq breath 0) (eq accent 1)) "ᾴ")
		((and (eq iotasub 1) (eq breath 0) (eq accent 2)) "ᾲ")
		((and (eq iotasub 1) (eq breath 0) (eq accent 3)) "ᾷ")
		((and (eq iotasub 1) (eq breath 1) (eq accent 0)) "ᾀ")
		((and (eq iotasub 1) (eq breath 2) (eq accent 0)) "ᾁ")
		((and (eq iotasub 1) (eq breath 1) (eq accent 1)) "ᾄ")
		((and (eq iotasub 1) (eq breath 2) (eq accent 1)) "ᾅ")
		((and (eq iotasub 1) (eq breath 1) (eq accent 2)) "ᾂ")
		((and (eq iotasub 1) (eq breath 2) (eq accent 2)) "ᾃ")
		((and (eq iotasub 1) (eq breath 1) (eq accent 3)) "ᾆ")
		((and (eq iotasub 1) (eq breath 2) (eq accent 3)) "ᾇ")
	    )
	)
	((string= ch "b") "β")
	((string= ch "q") "ψ")
	;((string= ch "4") "ψ")
	((string= ch "d") "δ")
	((string= ch "e")
	    (cond
	        ((and (eq breath 0) (eq accent 0)) "ε")
		((and (eq breath 0) (eq accent 1)) "έ")
		((and (eq breath 0) (eq accent 2)) "ὲ")
		((and (eq breath 0) (eq accent 3)) "ε")
		((and (eq breath 1) (eq accent 0)) "ἐ")
		((and (eq breath 2) (eq accent 0)) "ἑ")
		((and (eq breath 1) (eq accent 1)) "ἔ")
		((and (eq breath 2) (eq accent 1)) "ἕ")
		((and (eq breath 1) (eq accent 2)) "ἒ")
		((and (eq breath 2) (eq accent 2)) "ἓ")
		((and (eq breath 1) (eq accent 3)) "ἐ")
		((and (eq breath 2) (eq accent 3)) "ἑ")
	    )
        )
	((string= ch "f") "φ")
	((string= ch "g") "γ")
	((string= ch "h")
	    (cond
	        ((and (eq iotasub 0) (eq breath 0) (eq accent 0)) "η")
		((and (eq iotasub 0) (eq breath 0) (eq accent 1)) "ή")
		((and (eq iotasub 0) (eq breath 0) (eq accent 2)) "ὴ")
		((and (eq iotasub 0) (eq breath 0) (eq accent 3)) "ῆ")
		((and (eq iotasub 0) (eq breath 1) (eq accent 0)) "ἠ")
		((and (eq iotasub 0) (eq breath 2) (eq accent 0)) "ἡ")
		((and (eq iotasub 0) (eq breath 1) (eq accent 1)) "ἤ")
		((and (eq iotasub 0) (eq breath 2) (eq accent 1)) "ἥ")
		((and (eq iotasub 0) (eq breath 1) (eq accent 2)) "ἢ")
		((and (eq iotasub 0) (eq breath 2) (eq accent 2)) "ἣ")
		((and (eq iotasub 0) (eq breath 1) (eq accent 3)) "ἦ")
		((and (eq iotasub 0) (eq breath 2) (eq accent 3)) "ἧ")
	        ((and (eq iotasub 1) (eq breath 0) (eq accent 0)) "ῃ")
		((and (eq iotasub 1) (eq breath 0) (eq accent 1)) "ῄ")
		((and (eq iotasub 1) (eq breath 0) (eq accent 2)) "ῂ")
		((and (eq iotasub 1) (eq breath 0) (eq accent 3)) "ῇ")
		((and (eq iotasub 1) (eq breath 1) (eq accent 0)) "ᾐ")
		((and (eq iotasub 1) (eq breath 2) (eq accent 0)) "ᾑ")
		((and (eq iotasub 1) (eq breath 1) (eq accent 1)) "ᾔ")
		((and (eq iotasub 1) (eq breath 2) (eq accent 1)) "ᾕ")
		((and (eq iotasub 1) (eq breath 1) (eq accent 2)) "ᾒ")
		((and (eq iotasub 1) (eq breath 2) (eq accent 2)) "ᾓ")
		((and (eq iotasub 1) (eq breath 1) (eq accent 3)) "ᾖ")
		((and (eq iotasub 1) (eq breath 2) (eq accent 3)) "ᾗ")
	    )
        )
	((string= ch "i")
	    (cond
	        ((and (eq diaeresis 0) (eq breath 0) (eq accent 0)) "ι")
		((and (eq diaeresis 0) (eq breath 0) (eq accent 1)) "ί")
		((and (eq diaeresis 0) (eq breath 0) (eq accent 2)) "ὶ")
		((and (eq diaeresis 0) (eq breath 0) (eq accent 3)) "ῖ")
		((and (eq diaeresis 0) (eq breath 1) (eq accent 0)) "ἰ")
		((and (eq diaeresis 0) (eq breath 2) (eq accent 0)) "ἱ")
		((and (eq diaeresis 0) (eq breath 1) (eq accent 1)) "ἴ")
		((and (eq diaeresis 0) (eq breath 2) (eq accent 1)) "ἵ")
		((and (eq diaeresis 0) (eq breath 1) (eq accent 2)) "ἲ")
		((and (eq diaeresis 0) (eq breath 2) (eq accent 2)) "ἳ")
		((and (eq diaeresis 0) (eq breath 1) (eq accent 3)) "ἶ")
		((and (eq diaeresis 0) (eq breath 2) (eq accent 3)) "ἷ")
		((and (eq diaeresis 1) (eq accent 0)) "ϊ")
		((and (eq diaeresis 1) (eq accent 1)) "ΐ")
		((and (eq diaeresis 1) (eq accent 2)) "ῒ")
		((and (eq diaeresis 1) (eq accent 3)) "ῗ")
	    )
        )
	((string= ch "x") "ξ")
	;((string= ch "3") "ξ")
	((string= ch "5") "ς")
	;((string= ch "j") "ς")   ;?
	((string= ch "k") "κ")
	((string= ch "l") "λ")
	((string= ch "m") "μ")
	((string= ch "n") "ν")
	((string= ch "o")
	    (cond
	        ((and (eq breath 0) (eq accent 0)) "ο")
		((and (eq breath 0) (eq accent 1)) "ό")
		((and (eq breath 0) (eq accent 2)) "ὸ")
		((and (eq breath 0) (eq accent 3)) "ο")
		((and (eq breath 1) (eq accent 0)) "ὀ")
		((and (eq breath 2) (eq accent 0)) "ὁ")
		((and (eq breath 1) (eq accent 1)) "ὄ")
		((and (eq breath 2) (eq accent 1)) "ὅ")
		((and (eq breath 1) (eq accent 2)) "ὂ")
		((and (eq breath 2) (eq accent 2)) "ὃ")
		((and (eq breath 1) (eq accent 3)) "ὀ")
		((and (eq breath 2) (eq accent 3)) "ὁ")
	    )
        )
	((string= ch "p") "π")
	((string= ch "r") "ρ")
	((string= ch "s") "σ")
	((string= ch "t") "τ")
	((string= ch "u")
	    (cond
	        ((and (eq diaeresis 0) (eq breath 0) (eq accent 0)) "υ")
		((and (eq diaeresis 0) (eq breath 0) (eq accent 1)) "ύ")
		((and (eq diaeresis 0) (eq breath 0) (eq accent 2)) "ὺ")
		((and (eq diaeresis 0) (eq breath 0) (eq accent 3)) "ῦ")
		((and (eq diaeresis 0) (eq breath 1) (eq accent 0)) "ὐ")
		((and (eq diaeresis 0) (eq breath 2) (eq accent 0)) "ὑ")
		((and (eq diaeresis 0) (eq breath 1) (eq accent 1)) "ὔ")
		((and (eq diaeresis 0) (eq breath 2) (eq accent 1)) "ὕ")
		((and (eq diaeresis 0) (eq breath 1) (eq accent 2)) "ὒ")
		((and (eq diaeresis 0) (eq breath 2) (eq accent 2)) "ὓ")
		((and (eq diaeresis 0) (eq breath 1) (eq accent 3)) "ὖ")
		((and (eq diaeresis 0) (eq breath 2) (eq accent 3)) "ὗ")
		((and (eq diaeresis 1) (eq accent 0)) "ϋ")
		((and (eq diaeresis 1) (eq accent 1)) "ΰ")
		((and (eq diaeresis 1) (eq accent 2)) "ῢ")
		((and (eq diaeresis 1) (eq accent 3)) "ῧ")
	    )
        )
	((string= ch "c") "θ")
	((string= ch "w")
	    (cond
	        ((and (eq iotasub 0) (eq breath 0) (eq accent 0)) "ω")
		((and (eq iotasub 0) (eq breath 0) (eq accent 1)) "ώ")
		((and (eq iotasub 0) (eq breath 0) (eq accent 2)) "ὼ")
		((and (eq iotasub 0) (eq breath 0) (eq accent 3)) "ῶ")
		((and (eq iotasub 0) (eq breath 1) (eq accent 0)) "ὠ")
		((and (eq iotasub 0) (eq breath 2) (eq accent 0)) "ὡ")
		((and (eq iotasub 0) (eq breath 1) (eq accent 1)) "ὤ")
		((and (eq iotasub 0) (eq breath 2) (eq accent 1)) "ὥ")
		((and (eq iotasub 0) (eq breath 1) (eq accent 2)) "ὢ")
		((and (eq iotasub 0) (eq breath 2) (eq accent 2)) "ὣ")
		((and (eq iotasub 0) (eq breath 1) (eq accent 3)) "ὦ")
		((and (eq iotasub 0) (eq breath 2) (eq accent 3)) "ὧ")
	        ((and (eq iotasub 1) (eq breath 0) (eq accent 0)) "ῳ")
		((and (eq iotasub 1) (eq breath 0) (eq accent 1)) "ῴ")
		((and (eq iotasub 1) (eq breath 0) (eq accent 2)) "ῲ")
		((and (eq iotasub 1) (eq breath 0) (eq accent 3)) "ῷ")
		((and (eq iotasub 1) (eq breath 1) (eq accent 0)) "ᾠ")
		((and (eq iotasub 1) (eq breath 2) (eq accent 0)) "ᾡ")
		((and (eq iotasub 1) (eq breath 1) (eq accent 1)) "ᾤ")
		((and (eq iotasub 1) (eq breath 2) (eq accent 1)) "ᾥ")
		((and (eq iotasub 1) (eq breath 1) (eq accent 2)) "ᾢ")
		((and (eq iotasub 1) (eq breath 2) (eq accent 2)) "ᾣ")
		((and (eq iotasub 1) (eq breath 1) (eq accent 3)) "ᾦ")
		((and (eq iotasub 1) (eq breath 2) (eq accent 3)) "ᾧ")
	    )
        )
	((string= ch "j") "χ")
	((string= ch "z") "ζ")
	((string= ch "A")
	    (cond
	        ((and (eq breath 0) (eq accent 0)) "Α")
		((and (eq breath 0) (eq accent 1)) "Ά")
		((and (eq breath 0) (eq accent 2)) "Ὰ")
		((and (eq breath 0) (eq accent 3)) "Α")
		((and (eq breath 1) (eq accent 0)) "Ἀ")
		((and (eq breath 2) (eq accent 0)) "Ἁ")
		((and (eq breath 1) (eq accent 1)) "Ἄ")
		((and (eq breath 2) (eq accent 1)) "Ἅ")
		((and (eq breath 1) (eq accent 2)) "Ἂ")
		((and (eq breath 2) (eq accent 2)) "Ἃ")
		((and (eq breath 1) (eq accent 3)) "Ἆ")
		((and (eq breath 2) (eq accent 3)) "Ἇ")
	    )
        )
	((string= ch "B") "Β")
	((string= ch "Q") "Ψ")
	((string= ch "D") "Δ")
	((string= ch "E")
	    (cond
	        ((and (eq breath 0) (eq accent 0)) "Ε")
		((and (eq breath 0) (eq accent 1)) "Έ")
		((and (eq breath 0) (eq accent 2)) "Ὲ")
		((and (eq breath 0) (eq accent 3)) "Ε")
		((and (eq breath 1) (eq accent 0)) "Ἐ")
		((and (eq breath 2) (eq accent 0)) "Ἑ")
		((and (eq breath 1) (eq accent 1)) "Ἔ")
		((and (eq breath 2) (eq accent 1)) "Ἕ")
		((and (eq breath 1) (eq accent 2)) "Ἒ")
		((and (eq breath 2) (eq accent 2)) "Ἓ")
		((and (eq breath 1) (eq accent 3)) "Ε")
		((and (eq breath 2) (eq accent 3)) "Ε")
	    )
        )
	((string= ch "F") "Φ")
	((string= ch "G") "Γ")
	((string= ch "H")
	    (cond
	        ((and (eq breath 0) (eq accent 0)) "Η")
		((and (eq breath 0) (eq accent 1)) "Ή")
		((and (eq breath 0) (eq accent 2)) "Ὴ")
		((and (eq breath 0) (eq accent 3)) "Η")
		((and (eq breath 1) (eq accent 0)) "Ἠ")
		((and (eq breath 2) (eq accent 0)) "Ἡ")
		((and (eq breath 1) (eq accent 1)) "Ἤ")
		((and (eq breath 2) (eq accent 1)) "Ἥ")
		((and (eq breath 1) (eq accent 2)) "Ἢ")
		((and (eq breath 2) (eq accent 2)) "Ἣ")
		((and (eq breath 1) (eq accent 3)) "Ἦ")
		((and (eq breath 2) (eq accent 3)) "Ἧ")
	    )
        )
	((string= ch "I")
	    (cond
	        ((and (eq diaeresis 0) (eq breath 0) (eq accent 0)) "Ι")
		((and (eq diaeresis 0) (eq breath 0) (eq accent 1)) "Ί")
		((and (eq diaeresis 0) (eq breath 0) (eq accent 2)) "Ὶ")
		((and (eq diaeresis 0) (eq breath 0) (eq accent 3)) "Ι")
		((and (eq diaeresis 0) (eq breath 1) (eq accent 0)) "Ἰ")
		((and (eq diaeresis 0) (eq breath 2) (eq accent 0)) "Ἱ")
		((and (eq diaeresis 0) (eq breath 1) (eq accent 1)) "Ἴ")
		((and (eq diaeresis 0) (eq breath 2) (eq accent 1)) "Ἵ")
		((and (eq diaeresis 0) (eq breath 1) (eq accent 2)) "Ἲ")
		((and (eq diaeresis 0) (eq breath 2) (eq accent 2)) "Ἳ")
		((and (eq diaeresis 0) (eq breath 1) (eq accent 3)) "Ἶ")
		((and (eq diaeresis 0) (eq breath 2) (eq accent 3)) "Ἷ")
		((and (eq diaeresis 1) (eq accent 0)) "Ϊ")
		((and (eq diaeresis 1) (eq accent 1)) "Ι")
		((and (eq diaeresis 1) (eq accent 2)) "Ι")
		((and (eq diaeresis 1) (eq accent 3)) "Ι")
	    )
        )
	((string= ch "X") "Ξ")
	;((string= ch "#") "Ξ")
	((string= ch "K") "Κ")
	((string= ch "L") "Λ")
	((string= ch "M") "Μ")
	((string= ch "N") "Ν")
	((string= ch "O")
	    (cond
	        ((and (eq breath 0) (eq accent 0)) "Ο")
		((and (eq breath 0) (eq accent 1)) "Ό")
		((and (eq breath 0) (eq accent 2)) "Ὸ")
		((and (eq breath 0) (eq accent 3)) "Ο")
		((and (eq breath 1) (eq accent 0)) "Ὀ")
		((and (eq breath 2) (eq accent 0)) "Ὁ")
		((and (eq breath 1) (eq accent 1)) "Ὄ")
		((and (eq breath 2) (eq accent 1)) "Ὅ")
		((and (eq breath 1) (eq accent 2)) "Ὂ")
		((and (eq breath 2) (eq accent 2)) "Ὃ")
		((and (eq breath 1) (eq accent 3)) "Ὀ")
		((and (eq breath 2) (eq accent 3)) "Ὁ")
	    )
        )
	((string= ch "P") "Π")
	((string= ch "R") "Ρ")
	((string= ch "S") "Σ")
	((string= ch "T") "Τ")
	((string= ch "C") "Θ")
	;((string= ch "*") "Θ")
	((string= ch "W")
	    (cond
	        ((and (eq breath 0) (eq accent 0)) "Ω")
		((and (eq breath 0) (eq accent 1)) "Ώ")
		((and (eq breath 0) (eq accent 2)) "Ὼ")
		((and (eq breath 0) (eq accent 3)) "Ω")
		((and (eq breath 1) (eq accent 0)) "Ὠ")
		((and (eq breath 2) (eq accent 0)) "Ὡ")
		((and (eq breath 1) (eq accent 1)) "Ὤ")
		((and (eq breath 2) (eq accent 1)) "Ὥ")
		((and (eq breath 1) (eq accent 2)) "Ὤ")
		((and (eq breath 2) (eq accent 2)) "Ὣ")
		((and (eq breath 1) (eq accent 3)) "Ὦ")
		((and (eq breath 2) (eq accent 3)) "Ὧ")
	    )
        )
	;((string= ch "W") "΅")
	((string= ch "X") "Χ")
        ((string= ch "U")
	    (cond
	        ((and (eq diaeresis 0) (eq breath 0) (eq accent 0)) "Υ")
		((and (eq diaeresis 0) (eq breath 0) (eq accent 1)) "Ύ")
		((and (eq diaeresis 0) (eq breath 0) (eq accent 2)) "Ὺ")
		((and (eq diaeresis 0) (eq breath 0) (eq accent 3)) "Υ")
		((and (eq diaeresis 0) (eq breath 1) (eq accent 0)) "Υ")
		((and (eq diaeresis 0) (eq breath 2) (eq accent 0)) "Ὑ")
		((and (eq diaeresis 0) (eq breath 1) (eq accent 1)) "Υ")
		((and (eq diaeresis 0) (eq breath 2) (eq accent 1)) "Ὕ")
		((and (eq diaeresis 0) (eq breath 1) (eq accent 2)) "Υ")
		((and (eq diaeresis 0) (eq breath 2) (eq accent 2)) "Ὓ")
		((and (eq diaeresis 0) (eq breath 1) (eq accent 3)) "Υ")
		((and (eq diaeresis 0) (eq breath 2) (eq accent 3)) "Ὗ")
		((and (eq diaeresis 1)) "Ϋ")
	    )
        )
	((string= ch "J") "Χ")
	((string= ch "Z") "Z")
    )
    )
; (describe-function 'beta-char)

(defun reverse-string (st)
    "Takes string ST and returns it in reverse order."
    (if (< (length st) 2)
        st
	(let (n most last)
	    (setq n (length st))
	    (setq most (substring st 0 (- n 1)))
	    (setq last (substring st (- n 1) n))
	    (concat last (reverse-string most))
        )
    )
    )
; (describe-function 'reverse-string)

(defun beta-1 ()
    "Asks for a string of (Modified) Beta Code to decode, then decodes it and returns the result at 'point' (i.e., the text-cursor)."
    (interactive)
    (let (transcribendum outputst)
        (setq transcribendum (read-string "String to transcribe: "))
	(setq transcribendum (capital-trans transcribendum))
	(setq transcribendum (reverse-string transcribendum))
	;(y-or-n-p transcribendum)
	(setq breath 0)
	(setq accent 0)
	;(y-or-n-p transcribendum)
	(setq outputst (beta-trans-2 transcribendum))
	;(y-or-n-p outputst)
	(setq outputst (reverse-string outputst))
	;(y-or-n-p outputst)
	(insert outputst)
    )
)

(defun beta-trans-2 (st)
    "Decodes string ST (read in reverse order) taking into account breath marks et alii, building up an output string and then returning that string at the end."
    (let (char charnum outputst inschar)
        (setq outputst "")
	(setq breath 0)             ; reset global variables
	(setq accent 0)
	(setq diaeresis 0)
	(setq iotasub 0)
        (if (> (length st) 0)
            (while (> (length st) 0)   ; [st is not null] then while length(st)>0
                (setq char (substring st 0 1))            ; char := st[0]
		(setq charnum (aref char 0))              ; charnum := ASCII(char)
		(setq st (substring st 1 (length st)))      ; st := st[1:]
		;(y-or-n-p char)
		;(y-or-n-p (number-to-string charnum))
		(if (member charnum '(37 40 41 47 92 94 124))    ; if char is any of /\()^%|
		    (progn           ; [char is any of /\()^%| ] then
		        ;(y-or-n-p "SPECIAL")
		        (cond
			    ((eq charnum 47) (setq accent 1))       ; /
			    ((eq charnum 92) (setq accent 2))       ; \
			    ((eq charnum 94) (setq accent 3))       ; ^
			    ((eq charnum 41) (setq breath 1))       ; )
			    ((eq charnum 40) (setq breath 2))       ; (
			    ((eq charnum 37) (setq diaeresis 1))    ; %
			    ((eq charnum 124) (setq iotasub 1))     ; |
                        )
		    )
		    (progn                    ; [char is not any of /\()^%| ] so
		        ;(y-or-n-p "ORDINARY")
		        ;(insert (beta-char char))
			(setq inschar (beta-char char))       ; inschar := decode(char)
			;(y-or-n-p inschar)
			(setq outputst (concat outputst inschar))     ; outputst := outputst & inschar
			;(y-or-n-p outputst)
			(setq breath 0)                      ; reset the global variables
			(setq accent 0)
			(setq diaeresis 0)
			(setq iotasub 0)
		    )
		)
            )    ;end while
        )     ;end if
	outputst
    )
    )
; (describe-function 'beta-trans-2)

(defun capital-trans (st)
    "The function capital-trans capitalizes or lowercases letters in ST (and passes by other characters without changing them) based on whether or not the letter is immediately preceded by an asterisk."
    (let (char charnum outputst inschar)
        (setq outputst "")
	(setq asterisk 0)
        (if (> (length st) 0)
            (while (> (length st) 0)
                (setq char (substring st 0 1))
		(setq charnum (aref char 0))
		(setq st (substring st 1 (length st)))
		;(y-or-n-p char)
		;(y-or-n-p (number-to-string charnum))
                (if (eq charnum 42)
		    (setq asterisk 1)     ; [char is *] then asterisk=1
		    (if (and (>= charnum 97) (<= charnum 122))    ; else if char in 'a' to 'z'
                        (if (eq asterisk 0)               ; [char in 'a' to 'z'] then if asterisk==0
                            (setq outputst (concat outputst char))  ; [asterisk is 0] then outputst := outputst & char
			    (progn                                ; [asterisk is 1] so
                                (setq inschar "Z")
				(aset inschar 0 (- charnum 32))       ; inschar := capitalized(char)
				(setq outputst (concat outputst inschar))   ; outputst := outputst & inschar
				(setq asterisk 0)                     ;   reset asterisk
                            )
                        )
			(if (and (>= charnum 65) (<= charnum 90))   ; [char not in 'a' to 'z'] then if char in 'A' to 'Z'
                            (if (eq asterisk 1)         ; [char in 'A' to 'Z'] then if asterisk==1
			        (progn          ; [asterisk is 1] then 
                                    (setq outputst (concat outputst char))     ; outputst := outputst & char
				    (setq asterisk 0)                          ; reset asterisk
				)
				(progn          ; [asterisk is not 1] so
                                    (setq inschar "Z")
				    (aset inschar 0 (+ charnum 32))            ; inschar := lowercase(char)
				    (setq outputst (concat outputst inschar))   ; outputst := outputst & inschar
                                )
                            )
			    (progn            ; [char not in 'A' to 'Z'] so 
			        (setq outputst (concat outputst char))        ; outputst := outputst & char
				(setq asterisk 0)                             ; reset asterisk
			    )
                        )
                    )
		)
            )    ;end while
        )     ;end if
	outputst
    )
    )
; (describe-function 'capital-trans)
